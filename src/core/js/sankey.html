<!DOCTYPE html>
<meta charset="utf-8">
<title>SANKEY Experiment</title>
<style>
  .node rect {
    cursor: move;
    fill-opacity: .9;
    shape-rendering: crispEdges;
  }

  .node text {
    pointer-events: none;
    text-shadow: 0 1px 0 #fff;
  }

  .link {
    fill: none;
    stroke: #000;
    stroke-opacity: .2;
  }

  .link:hover {
    stroke-opacity: 0.5;
  }
  #intro {
  padding: 20px; 
  font-style: italic;
  font-size: 25px;
}
#myh2{
  text-align: center;
  padding: 10px;
}
#cont{
  
  padding-top: 20px;
  padding-left: 20px;
  padding-bottom: 10px;
}
#myh2{
  font-size: 40px;
}
#description{
  font-size: 25px;
  font-style:oblique ;
  padding-top: 20px;
  padding-left: 20px;
  padding-bottom: 20px;

}
</style>

<body>
  <h1 id="myh2"></h2>
    <p id="intro">We have plotted top 10 trees among the dataset for the northern and southern state, and the cities plotted for both Northern and soutehrn states are among the most top 20 greenest cities in the US </p>
   <div id="cont">
    <label for="stateDropdown">Select Northern or southern states:</label>
    <select id="stateDropdown" onchange="toggleState()">
      <option value="north">Northern States</option>
      <option value="south">Southern States</option>
    </select>
  </div> 
  <p id="chart"></p>
  <p id="description"></p>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
  <script>
    d3.sankey = function() {
      var sankey = {},
          nodeWidth = 24,
          nodePadding = 8,
          size = [1, 1],
          nodes = [],
          links = [];
     
      sankey.nodeWidth = function(_) {
        if (!arguments.length) return nodeWidth;
        nodeWidth = +_;
        return sankey;
      };
     
      sankey.nodePadding = function(_) {
        if (!arguments.length) return nodePadding;
        nodePadding = +_;
        return sankey;
      };
     
      sankey.nodes = function(_) {
        if (!arguments.length) return nodes;
        nodes = _;
        return sankey;
      };
     
      sankey.links = function(_) {
        if (!arguments.length) return links;
        links = _;
        return sankey;
      };
     
      sankey.size = function(_) {
        if (!arguments.length) return size;
        size = _;
        return sankey;
      };
     
      sankey.layout = function(iterations) {
        computeNodeLinks();
        computeNodeValues();
        computeNodeBreadths();
        computeNodeDepths(iterations);
        computeLinkDepths();
        return sankey;
      };
     
      sankey.relayout = function() {
        computeLinkDepths();
        return sankey;
      };
     
      sankey.link = function() {
        var curvature = .5;
     
        function link(d) {
          var x0 = d.source.x + d.source.dx,
              x1 = d.target.x,
              xi = d3.interpolateNumber(x0, x1),
              x2 = xi(curvature),
              x3 = xi(1 - curvature),
              y0 = d.source.y + d.sy + d.dy / 2,
              y1 = d.target.y + d.ty + d.dy / 2;
          return "M" + x0 + "," + y0
               + "C" + x2 + "," + y0
               + " " + x3 + "," + y1
               + " " + x1 + "," + y1;
        }
     
        link.curvature = function(_) {
          if (!arguments.length) return curvature;
          curvature = +_;
          return link;
        };
     
        return link;
      };
     
      // Populate the sourceLinks and targetLinks for each node.
      // Also, if the source and target are not objects, assume they are indices.
      function computeNodeLinks() {
        nodes.forEach(function(node) {
          node.sourceLinks = [];
          node.targetLinks = [];
        });
        links.forEach(function(link) {
          var source = link.source,
              target = link.target;
          if (typeof source === "number") source = link.source = nodes[link.source];
          if (typeof target === "number") target = link.target = nodes[link.target];
          source.sourceLinks.push(link);
          target.targetLinks.push(link);
        });
      }
     
      // Compute the value (size) of each node by summing the associated links.
      function computeNodeValues() {
        nodes.forEach(function(node) {
          node.value = Math.max(
            d3.sum(node.sourceLinks, value),
            d3.sum(node.targetLinks, value)
          );
        });
      }
     
      // Iteratively assign the breadth (x-position) for each node.
      // Nodes are assigned the maximum breadth of incoming neighbors plus one;
      // nodes with no incoming links are assigned breadth zero, while
      // nodes with no outgoing links are assigned the maximum breadth.
      function computeNodeBreadths() {
        var remainingNodes = nodes,
            nextNodes,
            x = 0;
     
        while (remainingNodes.length) {
          nextNodes = [];
          remainingNodes.forEach(function(node) {
            node.x = x;
            node.dx = nodeWidth;
            node.sourceLinks.forEach(function(link) {
              nextNodes.push(link.target);
            });
          });
          remainingNodes = nextNodes;
          ++x;
        }
     
        //
        moveSinksRight(x);
        scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
      }
     
      function moveSourcesRight() {
        nodes.forEach(function(node) {
          if (!node.targetLinks.length) {
            node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
          }
        });
      }
     
      function moveSinksRight(x) {
        nodes.forEach(function(node) {
          if (!node.sourceLinks.length) {
            node.x = x - 1;
          }
        });
      }
     
      function scaleNodeBreadths(kx) {
        nodes.forEach(function(node) {
          node.x *= kx;
        });
      }
     
      function computeNodeDepths(iterations) {
        var nodesByBreadth = d3.nest()
            .key(function(d) { return d.x; })
            .sortKeys(d3.ascending)
            .entries(nodes)
            .map(function(d) { return d.values; });
     
        //
        initializeNodeDepth();
        resolveCollisions();
        for (var alpha = 1; iterations > 0; --iterations) {
          relaxRightToLeft(alpha *= .99);
          resolveCollisions();
          relaxLeftToRight(alpha);
          resolveCollisions();
        }
     
        function initializeNodeDepth() {
          var ky = d3.min(nodesByBreadth, function(nodes) {
            return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
          });
     
          nodesByBreadth.forEach(function(nodes) {
            nodes.forEach(function(node, i) {
              node.y = i;
              node.dy = node.value * ky;
            });
          });
     
          links.forEach(function(link) {
            link.dy = link.value * ky;
          });
        }
     
        function relaxLeftToRight(alpha) {
          nodesByBreadth.forEach(function(nodes, breadth) {
            nodes.forEach(function(node) {
              if (node.targetLinks.length) {
                var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
                node.y += (y - center(node)) * alpha;
              }
            });
          });
     
          function weightedSource(link) {
            return center(link.source) * link.value;
          }
        }
     
        function relaxRightToLeft(alpha) {
          nodesByBreadth.slice().reverse().forEach(function(nodes) {
            nodes.forEach(function(node) {
              if (node.sourceLinks.length) {
                var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
                node.y += (y - center(node)) * alpha;
              }
            });
          });
     
          function weightedTarget(link) {
            return center(link.target) * link.value;
          }
        }
     
        function resolveCollisions() {
          nodesByBreadth.forEach(function(nodes) {
            var node,
                dy,
                y0 = 0,
                n = nodes.length,
                i;
     
            // Push any overlapping nodes down.
            nodes.sort(ascendingDepth);
            for (i = 0; i < n; ++i) {
              node = nodes[i];
              dy = y0 - node.y;
              if (dy > 0) node.y += dy;
              y0 = node.y + node.dy + nodePadding;
            }
     
            // If the bottommost node goes outside the bounds, push it back up.
            dy = y0 - nodePadding - size[1];
            if (dy > 0) {
              y0 = node.y -= dy;
     
              // Push any overlapping nodes back up.
              for (i = n - 2; i >= 0; --i) {
                node = nodes[i];
                dy = node.y + node.dy + nodePadding - y0;
                if (dy > 0) node.y -= dy;
                y0 = node.y;
              }
            }
          });
        }
     
        function ascendingDepth(a, b) {
          return a.y - b.y;
        }
      }
     
      function computeLinkDepths() {
        nodes.forEach(function(node) {
          node.sourceLinks.sort(ascendingTargetDepth);
          node.targetLinks.sort(ascendingSourceDepth);
        });
        nodes.forEach(function(node) {
          var sy = 0, ty = 0;
          node.sourceLinks.forEach(function(link) {
            link.sy = sy;
            sy += link.dy;
          });
          node.targetLinks.forEach(function(link) {
            link.ty = ty;
            ty += link.dy;
          });
        });
     
        function ascendingSourceDepth(a, b) {
          return a.source.y - b.source.y;
        }
     
        function ascendingTargetDepth(a, b) {
          return a.target.y - b.target.y;
        }
      }
     
      function center(node) {
        return node.y + node.dy / 2;
      }
     
      function value(link) {
        return link.value;
      }
     
      return sankey;
    };
  </script>
  <script>
    var units = "trees";

    var margin = { top: 50, right: 10, bottom: 10, left: 40 },
      width = innerWidth -250 - margin.left - margin.right,
      height = 600 - margin.top - margin.bottom;
    var linkColor = d3.scale.category20();
    var formatNumber = d3.format(",.0f"),
      format = function (d) {
        return formatNumber(d) + " " + units;
      },
      color = linkColor;
    
    var svg = d3.select("#chart")
      .append("svg")
      .attr("width", width + 180 + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom )
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var sankey = d3.sankey()
      .nodeWidth(16)
      .nodePadding(20)
      .size([width, height]);

    var path = sankey.link();

    function toggleState() {
      // Clear existing diagram
      svg.selectAll("*").remove();

      var checkbox = document.getElementById("stateCheckbox");
      var dataURL;

      if (stateDropdown.value === "north") {
        // Fetch data for Northern states
        dataURL =
          "https://raw.githubusercontent.com/hussein320/5MTREES_D3_DATA_Visualization/main/my_data//nodes_links10north.json";
        h2_value="Souththern States Sankey diagram"
        dedescription=" we can see in the northern states that the dominant trees are platanus acerifolia ,acer platanoides and  pyrus calleryanaacer rubrum which prefer cold weather but they adapt to wide range of weather"
        } 
      else {
        // Fetch data for Southern states
        dataURL =
          "https://raw.githubusercontent.com/hussein320/5MTREES_D3_DATA_Visualization/main/my_data//nodes_links10south.json";
        h2_value="Northern States Sankey diagram"
        dedescription=" we can see in the southern states that the dominant trees are lagerstroemia indica, platanus acerifolia, liquidambar styraciflua and quercus virginiana are adatable to wide range of weather but thry prefer warm color and they prefer sun "
      }
  document.getElementById("myh2").innerHTML = h2_value
  document.getElementById("description").innerHTML = dedescription
      fetch(dataURL)
        .then((response) => response.json())
        .then((graph) => {
          var nodeMap = {};
          graph.nodes.forEach(function (x) {
            nodeMap[x.name] = x;
          });
          graph.links = graph.links.map(function (x) {
            return {
              source: nodeMap[x.source],
              target: nodeMap[x.target],
              value: x.value,
            };
          });
          console.log(nodeMap);
          sankey.nodes(graph.nodes).links(graph.links).layout(30);

          var link = svg
            .append("g")
            .selectAll(".link")
            .data(graph.links)
            .enter()
            .append("path")
            .attr("class", "link")
            .attr("d", path)
            .style("stroke-width", function (d) {
              return Math.max(1, d.dy);
            })
            .sort(function (a, b) {
              return b.dy - a.dy;
            });

          link.append("title").text(function (d) {
            return (
              d.source.name + " → " + d.target.name + "\n" + format(d.value)
            );
          });

          var node = svg
            .append("g")
            .selectAll(".node")
            .data(graph.nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("transform", function (d) {
              return "translate(" + d.x + "," + d.y + ")";
            })
            .call(
              d3.behavior.drag().origin(function (d) {
                return d;
              })
            );

          node
            .append("rect")
            .attr("height", function (d) {
              return d.dy;
            })
            .attr("width", sankey.nodeWidth())
            .style("fill", function (d) {
              return (d.color = color(d.name.replace(/ .*/, "")));
            })
            .style("stroke", function (d) {
              return d3.rgb(d.color).darker(2);
            })
            .append("title")
            .text(function (d) {
              return d.name + "\n" + format(d.value);
            });

          node
            .append("text")
            .attr("x", 30)
            .attr("y", function (d) {
              return d.dy / 2;
            })
            .attr("dy", ".35em")
            .attr("text-anchor", "start")
            .attr("transform", null)
            .text(function (d) {
              return d.name;
            })
            .filter(function (d) {
              return d.x < width / 2;
            })
            .attr("x", 2 + sankey.nodeWidth())
            .attr("text-anchor", "start");

            svg
              .append("text")
              .attr("x", 0)
              .attr("y", 0)
              .attr("dy", "-1em")
              .attr("text-anchor", "start")
              .text("States")
              .style("font-size", "22");

            svg
              .append("text")
              .attr("x", width/2 )
              .attr("y", 0)
              .attr("dy", "-1em")
              .attr("text-anchor", "start")
              .text("Cities")
              .style("font-size", "22");

            svg
              .append("text")
              .attr("x", width )
              .attr("y", -65)
              .attr("dy", "2em")
              .attr("text-anchor", "start")
              .text("Trees")
              
              .style("font-size", "22");

          function dragmove(d) {
            d3.select(this).attr(
              "transform",
              "translate(" +
                (d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))) +
                "," +
                (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) +
                ")"
            );
            sankey.relayout();
            link.attr("d", path);
          }
        });
    }

    // Initial fetch for Northern states
    toggleState();
  </script>



</body>

</html>